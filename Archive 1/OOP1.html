<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Basic OOP</title>
    <link rel="icon"
      type="image/png"
      href="favicon.png">
    <link href="https://fonts.googleapis.com/css?family=Cardo:400,700|Oswald" rel="stylesheet">
</head>

<!---BODY--->
<body>
  <div class="topnav">
      <a class="home" href="index.html">Home</a>
      <a href=OOP1.html>OOP - Part 1</a>
      <a href=OOP2.html>OOP - Part 2</a>
      <a href=Arrays.html>Arrays</a>
      <a href=ArrayList.html>ArrayLists</a>
      <a href=Sorting.html>Sorting</a>
      <a href=Searching.html>Searching</a>
      <a href=Recursion.html>Recursion</a>
      <a href="Projects.html">Projects</a>
      <a href="bibliography.html">Bibliography</a>
  </div>

<style>
    html {
        overflow-y: auto;
        margin: 3em;
    }

    body, pre {
        font-family: 'Oswald', serif;
        background: url(OOP1Background.jpg) no-repeat center center fixed;
        height: 100%;
        overflow: hidden;
        background-size: cover;
        font-size: 4vw;
        color: white;
    }

    b.title {
        font-size: 3vw;
    }

    th, td{
      padding: 5px;
      text-align: left;
      font-size: 1.7vw;
      border: 1px solid black;
      border-collapse: collapse;
    }

    p,ol, pre, li, ul {
        font-size: 1.5vw;
    }

    /*------TOP NAV BAR------*/
    .topnav {
        overflow: hidden;
        background-color: ghostwhite;
    }

    .topnav a {
        float: left;
        color: black;
        text-align: center;
        padding: 14px 16px;
        text-decoration: none;
        font-size: 1.4vw;
    }

    .topnav a:hover {
        background-color: #ddd;
        color: black;
    }

    .topnav a.home {
        background-color: orangered;
        color: white;
    }

    a.link:link{
      color: white
    }

    /* visited link */
    a.link:visited {
        color: white;
    }

    /* mouse over link */
    a.link:hover {
        color: darkred;
    }

    /* selected link */
    a.link:active {
        color: palevioletred;
</style>
<h1>
  <center>
    OBJECTS AND CLASSES (OOP)
  </center>
</h1>

<p>
    <b class="title">
        CLASSES
    </b>
    <br> In Java, there are two types of classes: Utility classes and object classes (often just refered to as a normal class).
    Utility classes are classes not meant to be <i>instatiated</i>, and only contain
    static helper methods and fields. Object classes are classes meant to be <i>instatiated</i>.
    They are essentially blueprints to create <i>objects.</i> Object classes <b>need</b>
    to include a constructor, and can have methods and fields too.

    <table style="width:100%">
      <tr>
        <th>Utility Class</th>
        <th>Object Class</th>
      </tr>
      <tr>
        <td>
        <pre>
          public class Utility{
            public static int add(int a, int b){
              return a + b;
            }

            public static int subtract(int a, int b){
              return a - b;
            }

            public static int multiply(int a, int b){
              return a * b;
            }

            public static int divide(int a, int b){
              return a / b;
            }

            public static int mod(int a, int b){
              return a % b;
            }
          }
        </pre>
        </td>
        <td>
        <pre>
          public class BankAccount{
            //fields
            private int num;
            private int balance;
            //constructor
            public BankAccount(){
              num = 0;
              balance = 0;
            }
            public BankAccount(int number, int balance){
              this.num = number;
              this.balance = balance;
            }
            //methods
            public int getNum(){
              return num;
            }

            public int getBalance(){
              return balance;
            }

            public void incBalance(int increment){
              this.balance = <i>add</i>(balance, increment); //add() method from our utility class
            }
          }
        </pre>
        </td>
      </tr>
    </table>
  </p>
  <p>
    <br><br>
    <b class="title">
        OBJECTS
    </b>
    <br>Objects are <i>instances</i> of classes, that contain a copy of the class's
    instance variables and method. An example of a Real-World "object" can be a Dog.
    It's methods would be bark(), eat(), sleep(), getName(), setName(), and so on that
    would simulate the dog's abilities. It's fields could be String name, int age,
    String gender, and attributes to describe it.
    <br>Objects are created with the <b>new</b> keyword,like such:
    <br><code>Object name = new Object(/*Constructor parameters*/)</code>
    <br>So if you wanted to create a BankAccount object (look at OOP class example
    above) called "obj" with a number of 12345 and balance of 15$, you'd do.
</p>
<pre>
      BankAccount obj = new BankAccount(12345, 15);
</pre>
<p>
    <b><a class = "link" href="Don't_Fear_The_OOP_BillBai_RohanKrishna.html"> Here </a></b>
    is an example of OOP.
    <br><br>
    <b class = "title">What is OOP?</b>
      <br>Object Oriented Programming is a style of programming that revolves around
      the uses of <b>objects</b> that communicate with each other to get a certain
      task accomplished. <br><b>The four principles of object-oriented
    programming are encapsulation, abstraction, inheritance, and polymorphism.</b>
    <br><br>
</p>
<center>
<h1>ENCAPSULATION</h1>
  <img src="OOP1Encapsulation.jpg" alt="Encapsulation" width=50% height=50%>
</center>
<p>
  <br>
Encapsulation revolves around the idea that some data of an object
should have limited access from other objects or classes. This in turn requires
the programmer to create methods accessible by all to be able to access or modify
the hidden data. Encapsulation in Java works by using <i>access modifiers</i>.
<center>
  <img src="OOP1AccessModifier.png" alt="Encapsulation" width=50% height=50%>
  <p>The 4 access modifiers.</p>
</center>
</p>
<p>
<br>As you can see in the picture, there are 4 access modifiers in Java. The <b>
default </b>modifier allows every class within the same package to access it's data,
the <b>private</b> modifier allows only itself to access it's data, the <b>protected</b>
modifier allows the class's subclasses to access the data, and finally the public modifier
allows all classes to access it's data.
<br>To allow other classes to communicate, while still hiding data, you must use
<b>accessor</b> and <b>mutator</b> methods, often known as <b>getter</b> and <b>setter</b> methods.
<br><br>An <b>accessor</b> method only returns the field that needs to be accessed.
</p>
<pre>
class A{
  private int hidden;
  public A(){
    hidden = 0;
  }

  //Returns the <b>private</b> field, to allow access
  public int getHidden(){
    return hidden;
  }
}
</pre>
<p>
Notice how <i>getHidden()</i> is public. This allows every other class to <b>access</b>
hidden, which is the point of the method.
<br><br><b>Mutator methods</b> are methods that allow you to change a field in an object.
</p>
<pre>
  class A{
    private int hidden;
    public A(){
      hidden = 0;
    }

    public void setHidden(int change){
      hidden = change;
    }
  }
</pre>
<p>
Once again this method is public to allow other classes to use it. As well, the method
changes hidden, making it a <b>mutator method</b>.
<br>Encapsulation in Java is makes code maintainence easier. If a programmer accessed
all variables directly without any methods, a change to an algorithm would take
much longer since they'd have to change all occurences of the directly accessed variable.
Since encapsulation required methods to be used, instead of changing all occurences, the
programmer would only have to change the accessor/mutator method.
<br>As well, it makes it easier to debug since the variables are in a controlled
environment, where access can be prohibited to other classes and methods.
<br><br>
<b class = "title">ANALYSIS</b><br>
Encapsulation is an important OOP concept. It is essentially data hiding, and
allowing only certain classes to access it's data. It makes code maintenance much
easier, and improves debugging.
<br><br>
</p>
<center>
  <h1>INHERITANCE</h1>
    <img src="OOP1Inheritance.png" alt="Abstraction" width=50% height=50%>
    <p>Inheritance in java.</p>
</center>
<p>
  <br> Inheritance plays a big role in Object Oriented Programming. By definition,
  inheritance is when a class derives from another class. This means when <i>class A</i>
  inherits <i>class B</i> it <i>inherits</i> all public, protected, or default methods
  and fields of the class it inherits from.<br><br>
  <b class = "title">
    Terminology
  </b>
  <br>
  <b>Superclass</b> - In a relationship between two objects, the superclass is
  the class that is being derived from.<br>
  <b>Subclass</b> - In a relationship between two objects, the subclass is the
  derived superclass.<br>
  <b>Is-a</b> - A term used to show an inheritance relationship between two objects
  Example: Cake <i>is-a</i> food, and a Bike <i>is-a</i> vehicle.<br>
  <b>Has-a</b> - A term used to show a composition relationship between two objects
  Example: A Cake <i>has-a</i> Candle, and a Bike <i>has-a</i> bell.<br>
  <b>Overriding</b> - Rewriting/adding lines to inherited methods, to better suit
  the subclass <br>
  <b>super</b> - This <b>keyword</b> calls a method or field in the superclass. Example:
  to call the superclass constructor, you can write super(). To call a  superclass
  method, you'd do super.methodName().To call it in the subclass. To access a public variable,
  do super.variableName.<br>
  <b>this</b> - <b>this</b> refers to the current object that is being worked upon.
  <br><br>
  <br>
  <b class = "title">
    Why inheritance?
  </b>
  <br>Since inheritance allows you to <i>inherit</i> accesssible methods and fields of
  a superclass, it allows the programmer to cut down on code length, and also allows
  <i>downcasting and upcasting</i>, as well as <i>polymorphism</i>, which will be
  taught later.<br><br>
  <b class = "title">
    How?
  </b>
  <br>To inherit methods of a subclass, you use the keyword <b>extends</b> or
  <b>implements</b> depending on the superclass.
  <br>If you are trying to inherit an <i>abstract</i> class or regular class,
  you use the keyword <b>extends</b> as such:
</p>
<pre>
      public class A{
        //code
      }

      public class B <b>extends</b> A{
        //code
      }

      abstract class A{
        //code
      }

      public class B <b>extends</b> A{

      }
</pre>
<p>
  If you are trying to inherit an interface, you'd use the <i>implements</i> keyword as such:
</p>
<pre>
      public interface A{
          //code
      }

      public class B <b>implements</b> A{
        //code
      }
</pre>
<p>If an inherited method doesn't suit the subclass as well as it does with the
superclass, then you can always override the method. In the subclass, just  </p>
<p>
  <br>
  <b class = "title">
    Inheritance and constructors...
  </b>
  <br>When inheriting from an class, take note that subclasses <b>DO NOT</b> inherit
  constructors. Instead, if you'd like to call the superclass constructor in the
  constructor of the subclass, use the super() method.
</p>
<pre>
class A{
  public A(/*parameters*/){
    //code
  }
  //fields and methods not shown
}

class B <b>extends</b> A{
  public B(/*parameters*/){
    super(/*class A's parameters*/);
    //more code to better suit B
  }
  //fields and methods not show
}
</pre>
<p>
This allows class B to use class A's default constructor, since constructor inheritance
isn't possible.
<br>
<b class = "title">
  Analysis
</b>
<br>If you had a class with tens of thousands of code that another class can also use,
it would be best to take advantage of <i>inheritance</i>. Otherwise, you'd have to rewrite
those tens of thousands of lines of code! This would cause the program to take much
more computer storage.
<br>Take advantage of the <b>super</b> and <b>this</b> keyword, as they are very powerful,
allowing you to cut down on code.
<br>As well, inheritance allows you to use <i>abstract classes, interfaces, polymorphism</i>,
and much more!
</p>
<center>
  <h1>ABSTRACTION</h1>
    <img src="OOP1Abstraction.png" alt="Abstraction" width=50% height=50%>
    <p>Abstraction in java.</p>
</center>
<p><br>Abstraction in Java is another simple concept. It takes advantage of <i>inheritance</i>.
<br>Abstraction consists of <i>interfaces</i> and <i>abstract classes</i>. Abstract classes and
interfaces both serve as blueprints to an object, but have different uses. They both
contain <i>abstract methods</i>, which are methods that are only declared, but not
implemented. This is what allows abstract classes and methods to be so efficient as
<b>blueprints</b>.
</p>
<center>
  <b class = "title">
    Abstract class vs Interface
  </b>
</center>
<p>
<table style="width:100%">
  <tr>
    <th>Abstract Class</th>
    <th>Similarities</th>
    <th>Interface</th>
  </tr>
  <tr>
    <td>
      <ul>
        <li>
          A class can only extend one abstract class
        </li>
        <li>
          Can be instantiated if you create a subclass and upcast
        </li>
        <li>
          May contain non-final variables / instance variables
        </li>
        <li>
          Can provide implementations for it’s methods
        </li>
        <li>
          Can have protected, private, public, etc members
        </li>
        <li>
          Can implement interfaces
        </li>
      </ul>
    </td>
    <td>
      <ul>
        <li>
          In both, empty methods are recognized as abstract methods by the compiler
        </li>
        <li>
          Can not be instantiated
        </li>
        <li>
          If extended / implemented, the class must define all of the methods of
           the interface(s) and/or class
        </li>
      </ul>
    </td>
    <td>
      <ul>
        <li>
          Multiple interfaces can be implemented by a class
        </li>
        <li>
          Variables declared are final static by default
        </li>
        <li>
          Does not contain instance variables
        </li>
        <li>
          Can’t provide implementations for it’s methods
        </li>
        <li>
          Members are public by default
        </li>
          Interface can extend one or more interfaces but can’t implement anything
        </li>
      </ul>
    </td>
  </tr>
</table>
</p>
<p>
<b class = "title">
  When do I define an abstract class?
</b>
<br>A programmer should define a class as abstract when they need an inherited class
 represent the basic outline of the object. It contains common methods and attributes
  to be included in it’s subclasses. The class cannot be instantiated itself, and
  it’s only purpose is to be extended. You should use it if you want to define what
   the object is, rather than what it can do. For example, instead of defining what
    actions animals should be able to do in it, you define what animal it is. In the
     abstract class, you make it contain fields and methods that one or more very
      closely related classes would use.
      <br><br>
<b class = "title">
  When do I define an interface?
</b>
<br>An interface is very similar to an abstract class, but still has some differences.
 Unlike an abstract class, you should use an interface to define what the object can
  do, rather than what it is. For example, in the interface, you say that this
  certain object should walk(), eat(), sleep(), and more if you want. You do not
   define what the object is, which is why you can use interfaces less sparingly
    for unrelated classes. For example, you could implement an interface that
     defines what animals can do, for a Bird class, a Dog class, and a Cat class,
      as opposed to abstract classes, where they should only be used to define only
       what animal the object is, which is why you use it more sparingly for a certain
        family of very similar classes. Interfaces should also be taken advantage of,
         because you can implement more than one interface, which can be used to define
          more of what an object can do.<br><br>
  <b class = "title">
    How do I create Abstract Classes and Interfaces?
  </b>
  <table width = 100%>
    <tr>
      <th>Abstract Class</th>
      <th>Interface</th>
    </tr>
    <tr>
      <td>
        <pre>
        public <b>abstract</b> class AbClass{
          int a;
          int b;
          int c;
          public void filledMethod(){
            //code
          }
          public void method1(); //abstract method
          public void method 2(); //abstract method
        }

        public class B <b>extends</b> abClass{
          public void method1(){
            //code
          }

          public void method2(){
            //code
          }

          //other fields and methods hidden
        }
      </pre>
      </td>
      <td>
        <pre>
        public <b>interface</b> InClass{
          public void method1(); //abstract method
          public void method2(); //abstract method
        }

        public class B <b>implements</b> InClass{
          public void method1(){
            //code
          }

          public void method2(){
            //code
          }
          //other fields and methods hidden
        }
      </pre>
      </td>
    </tr>
  </table>
</p>
<p>
  As you can see, abstract methods are able to contain fields and completed methods,
  while the interface can only contain <i>abstract</i> methods. In both subclasses,
  the methods must be implemented, or it will throw an error.
  <br><br>
  <b class = "title">ANALYSIS</b><br>
  In Java, abstraction allows easier planning of classes, and makes OOP much simpler.
  It involves using abstract classes or interfaces, or even a mix of both! You must
  <b>extend </b>an abstract class, and <b>implement</b> an interface. Use abstract classes
  when you are creating a blueprint for a family of classes, and interface when
  you are creating a blueprint for generic classes that can have no relations.
  <br><br>
  <b class = "title">PROBLEM: Create an interface for a "FlyingAnimal". Then use inheritance
  to create a "Bird" class, with appropriate access modifiers. <br><br>
SOLUTION:</b>
</p>
<pre>
<center>
<table>
<tr>
<td>
/**
 * This is an interface to represent a flying animal.
 *
 * @author Bill Bai
 * @version 1.0 May 5, 2019
 */
public interface FlyingAnimal{
 /**
  * This method simulates flying
  */
  public void fly();

 /**
  * This method checks if the animal's wings are in good health
  *
  * @return A boolean that is true if wings are in good health, false otherwise
  */
  public boolean checkWingStatus();

 /**
  * This method simulates eating
  */
  public void eat();
}

/**
 * This class implements FlyingAnimal and is an object class for a Bird
 *
 * @author Bill Bai
 * @version 1.0 May 5, 2019
 */
public class Bird implements FlyingAnimal{
  private int hunger; //The animal's hunger
  private int distance; //How far the animal has travelled
  private int wingHealth; //Wing's health

  /**
   * Bird object constructor
   */
  public Bird(){
    hunger = 100;
    distance = 0;
    wingHealth = 100;
  }

  /**
   * This method simulates flying by adding 100 to distance
   */
  public void fly(){
    distance += 100;
    wingHealth -= 5;
  }

  /**
   * This method checks if the animal's wings are in good health
   *
   * @return A boolean that is true if wings are in good health, false otherwise
   */
  public void checkWingStatus{
    if(wingHealth > 50)
      return true;
    else
      return false;
  }

  /**
   * This method simulates eating by adding 5 to wingHealth
   */
  public void eat(){
    wingHealth += 5;
  }


  /**
   * This accessor method returns the animal's hunger
   *
   * @return The variable hunger.
   */
  public int getHunger{
    return hunger;
  }
}

How I solved this problem: First I created an interface called "FlyingAnimal" and inserted
a few methods that I thought a flying animal would possess. I then created the Bird class
and <b>implemented</b> (Don't extend!) the interface, and set all fields to private, since
they will <b>not</b> have to be accessed directly for any reason. I then created the
constructor, then implemented the rest of the methods (This is a must, since you need to
implement abstract methods), as well as adding accessor methods to allow a user or client
to access the private variables, which is a key part of encapsulation.
</td>
</tr>
</table>
</center>
</pre>
<h2>
  <center>
    <a class = "link" href="https://github.com/billbai0102/OOP1" target="_blank">
      Click here for independent examples of basic OOP!
    </a>
  </center>
</h2>
</body>
</html>
