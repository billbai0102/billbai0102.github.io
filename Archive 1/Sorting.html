<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sorting</title>
    <link rel="icon"
      type="image/png"
      href="favicon.png">
    <link href="https://fonts.googleapis.com/css?family=Cardo:400,700|Oswald" rel="stylesheet">
</head>

<!---BODY--->
<body>

  <div class="topnav">
      <a class="home" href="index.html">Home</a>
      <a href=OOP1.html>OOP - Part 1</a>
      <a href=OOP2.html>OOP - Part 2</a>
      <a href=Arrays.html>Arrays</a>
      <a href=ArrayList.html>ArrayLists</a>
      <a href=Sorting.html>Sorting</a>
      <a href=Searching.html>Searching</a>
      <a href=Recursion.html>Recursion</a>
      <a href="Projects.html">Projects</a>
      <a href="bibliography.html">Bibliography</a>
  </div>

<style>
    html {
        overflow-y: auto;
        margin: 3em;
    }

    body, pre {
        font-family: 'Oswald', serif;
        background: url(SortBackground.jpeg) no-repeat center center fixed;
        height: 100%;
        overflow: hidden;
        background-size: cover;
        font-size: 4vw;
        color: white;
    }

    b.title {
        font-size: 3vw;
    }

    th, td{
      padding: 5px;
      text-align: left;
      font-size: 1.7vw;
      border: 1px solid black;
      border-collapse: collapse;
    }

    p,ol, pre, li, ul {
        font-size: 1.5vw;
    }

    /*------TOP NAV BAR------*/
    .topnav {
        overflow: hidden;
        background-color: ghostwhite;
        font-size: 1.4vw;
    }

    .topnav a {
        float: left;
        color: black;
        text-align: center;
        padding: 14px 16px;
        text-decoration: none;
    }

    .topnav a:hover {
        background-color: #ddd;
        color: black;
    }

    .topnav a.home {
        background-color: orangered;
        color: white;
    }
    a.link:link{
      color: white
    }

    /* visited link */
    a.link:visited {
        color: white;
    }

    /* mouse over link */
    a.link:hover {
        color: darkred;
    }

    /* selected link */
    a.link:active {
        color: palevioletred;
</style>
<h1>
    <center>SORTING</center>
</h1>

<p>
    <b class="title">
        WHAT IS SORTING?
    </b>
    <br> Sorting is the process of arranging an array in a particular order, usually
    in ascending or descending order.
    <br> In this tutorial, there will be information on the Quicksort. Before
    we get started on learning about the sort, let's discuss <i>efficiency</i>.
    <br><br>
    <b class="title">
        Efficiency?
    </b>
    <br> In programming terms, efficiency is the measure of how much computational
    resources an algorithm uses. It is split into two segments: Time complexity, and
    Space complexity. It is typically displayed in big O notation ( such as O(n) time complexity),
    where the function inside of the brackets dictates the rate of growth of the algorithm
    <br><br>
    <b>Time complexity</b> is the measure of how much <i>time</i> an algorithm takes
    to run. Specifically, it is measured in how many times an elementary operation is
    performed which includes "=","+","-","*","/", "%", "<", ">", "&&", "||", "!", and "^".
    <br>If the time complexity was O(n), that means every single element in the array was proccessed,
    causing to have a linear time complexity. In general, The smaller the <i>n</i> inside of the
    brackets, the more efficient. <code>O(1)</code> time would be the fastest, and <code>O(âˆž)</code> being the slowest.
    <br><br>
    <b>Space complexity</b> is the measure of how much memory an algorithm takes up. This
    includes memory allocated to ints, Strings, objects, and anything that uses memory.
    <br>Like time complexity, the lower <i>n</i> is, the more efficient it is.
    <br><br>
    <b class="title">
        QUICKSORT
    </b>
    <br>The linear search, sometimes also known as the sequential search, is the
    simplest and most straightforward search. It involves looping through each
    and every element in an array, and checking if the element is equal to the
    key.
    <br>It is typically performed on unsorted arrays or arrays with few elements.
    The following code below is that of the linear search.
</p>
<ol>

</ol>
<center>
  <img src="QuickSortDiagram.png" alt="Quicksort Diagram" width=50% height=50%>
  <p>Quicksort Visualized.</p>
</center>
<table style="width:100%">
  <tr>
    <th>Array Implementation</th>
    <th colspan="2">ArrayList Implementation</th>
  </tr>
  <tr>
    <td>
    <pre>
      public void quickSort(int arr[], int begin, int end) {
          if (begin < end) {
              int index = partition(arr, begin, end);

              quickSort(arr, begin, index-1);
              quickSort(arr, index+1, end);
          }
      }

      public int partition(int arr[], int left, int right){
          int i = left
          int j = right;
          int tmp;
          int pivot = arr[(left + right) / 2];
          while (i <= j) {
              while (arr[i] < pivot)
                  i++;
              while (arr[j] > pivot)
                  j--;
              if (i <= j) {
                  tmp = arr[i];
                  arr[i] = arr[j];
                  arr[j] = tmp;
                  i++;
                  j--;
              }
        }
        return i;
    }
    </pre>
    </td>
    <td>
    <pre>
      public void quickSort(List&ltInteger&gt arr, int begin, int end) {
          if (begin < end) {
              int index = partition(arr, begin, end);

              quickSort(arr, begin, index-1);
              quickSort(arr, index+1, end);
          }
      }

      public int partition(List&ltInteger&gt arr, int left, int right){
          int i = left
          int j = right;
          int tmp;
          int pivot = arr[(left + right) / 2];
          while (i <= j) {
              while (arr[i] < pivot)
                  i++;
              while (arr[j] > pivot)
                  j--;
              if (i <= j) {
                  tmp = arr[i];
                  arr[i] = arr[j];
                  arr[j] = tmp;
                  i++;
                  j--;
              }
        }
        return i;
    }
    </pre>
    </td>
  </tr>
</table>
<center>
  <img src="Quicksort Diagram.png" alt="Quicksort Diagram" width=25% height=25%>
  <p>Here is a visual to help you understand Quicksort.</p>
</center>
<p>
  The efficiency of Quicksort is O(n log(n)) time, with a space complexity of
  O(log(n)). This means quicksort is efficient for most scenarios, although
  it's time efficiency isn't amazing. It is best used
  <br><b>NOTE: </b>When implementing quicksort, ALWAYS either choose the middle
  element as the pivot, or randomize the pivot. This is because when leftmost
  or rightmost element is chosen as the pivot, the quicksort ends up looking
  like a skewed binary tree, which causes it to be less efficient than it could be.
  <center>
    <img src="SkewedTree.jpg" alt="Quicksort Diagram" width=50% height=50%>
    <p>Skewed Tree vs Balanced Tree</p>
  </center>
<p>
<h2>
  <center>
  <a class = "link" href="https://github.com/billbai0102/ArrayExamples" target="_blank">
    Click here for independent examples of sorting!
  </a>
  </center>
</h2>
</body>
</html>
